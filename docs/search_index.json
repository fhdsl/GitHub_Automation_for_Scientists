[["index.html", "GitHub Automation for Scientists About this Course", " GitHub Automation for Scientists October, 2023 About this Course This course is part of a series of courses for the Informatics Technology for Cancer Research (ITCR) called the Informatics Technology for Cancer Research Education Resource. This material was created by the ITCR Training Network (ITN) which is a collaborative effort of researchers around the United States to support cancer informatics and data science training through resources, technology, and events. This initiative is funded by the following grant: National Cancer Institute (NCI) UE5 CA254170. Our courses feature tools developed by ITCR Investigators and make it easier for principal investigators, scientists, and analysts to integrate cancer informatics into their workflows. Please see our website at www.itcrtraining.org for more information. "],["introduction.html", "Chapter 1 Introduction 1.1 Target Audience 1.2 Topics covered 1.3 Motivation 1.4 Curriculum 1.5 How to use the course", " Chapter 1 Introduction 1.1 Target Audience The course is intended for students in the biomedical sciences and researchers who use informatics tools in their research This course is written for individuals who: Are comfortable with GitHub and know how to make a pull request Wish to save time and enhance their scientific projects using automation Perhaps previously tried to learn about GitHub Actions but felt overwhelmed on how to get started 1.2 Topics covered This course covers how to use GitHub actions for scientific software development. We encourage the recognition that scientific software can take many forms that can all benefit from the concepts of continuous integration and continuous deployment. This course builds on concepts introduced in the Reproducibility and Advanced Reproducibility courses from the ITCR Training Network. If you are unfamiliar with GitHub and/or do not have an account, we’d suggest you start with those courses by using the links or QR codes below. 1.3 Motivation Cancer datasets are plentiful, complicated, and hold untold amounts of information regarding cancer biology. Cancer researchers are working to apply their expertise to the analysis of these vast amounts of data but training opportunities to properly equip them in these efforts can be sparse. This includes training in reproducible data analysis methods. Data analyses are generally not reproducible without direct contact with the original researchers and a substantial amount of time and effort (Beaulieu-Jones and Greene 2017). Reproducibility in cancer informatics (as with other fields) is still not monitored or incentivized despite that it is fundamental to the scientific method. Despite the lack of incentive, many researchers strive for reproducibility in their own work but often lack the skills or training to do so effectively. Equipping researchers with the skills to create reproducible data analyses increases the efficiency of everyone involved. One tool among many for creating reproducible analyses is utilizing automation. Many individuals performing analyses on cancer data may not have formal training in software development and may be unfamiliar with the ideas of continuous integration and continuous deployment. By recognizing that biological data analysis code is a form of software development, we can try to adapt good development practices in scientific analyses and software contexts. Scientific software projects may include (but aren’t limited to): Software that built as tools to be utilized by others to analyze biologically derived data. Code that is built primarily for analyzing one project’s data. Code that is built as a workflow for a series of steps and analyses that might be reused among collaborators or within a lab. Any scripts and code that are built to handle data in a research setting. Any scripts and code a researcher might interact with. 1.4 Curriculum The course includes hands-on exercises for how to understand, build, and troubleshoot GitHub Actions as a continuous integration/continuous deployment tool for scientific software projects. Goal of this course: Equip learners with basics skills and confidence to utilize the concepts of continuous integration in the context of scientific software. What is not the goal This course is meant to teach learners how to create sophisticated GitHub Actions, but instead introduce learners to basic fundamentals of continuous integration and continuous deployment. This course focuses on GitHub Actions and will not cover any other (perfectly fine) tools for CI/CD. 1.5 How to use the course Ideally you should follow along with the chapters and perform they activities as they are described. These activities involve using GitHub and GitHub actions. You will need a GitHub account and basic familiarity with GitHub. References "],["programming-practices.html", "Chapter 2 Programming Practices", " Chapter 2 Programming Practices "],["why-automation.html", "Chapter 3 Why Automation", " Chapter 3 Why Automation "],["github-actions-fundamentals.html", "Chapter 4 GitHub Actions Fundamentals 4.1 GHA structure 4.2 Exercise 1 - Running your first GitHub Action", " Chapter 4 GitHub Actions Fundamentals 4.1 GHA structure All GitHub Actions involve answering three questions: When should a thing run? What should be run? With what environment should the thing be run? These questions and other specifications are set by writing a YAML file. YAML files are human readable markup language files. Basically its a list that is easy for humans to read and write and computers can read them too. This makes it good for writing a GitHub Action. Essentially, we’re going to write a YAML file to make a recipe that GitHub will read to know what/when/with what we are trying to do. The headlines about working with YAML files: Everything is a list (kind of like a JSON file). Indentations = subsets of a list Spacing is VERY specific! – incorrect spacing will definitely result in errors for your GitHub Action run. Let’s take a look at an example YAML. Note that the what comes before a : is generally a name and indent indicate subsets of a list. So in the overall list of food we have sublists of vegetables and fruits. # can be used as a comment and will not be treated as code. Additionally, : are often names. So citrus is the name for the item oranges and etc. # A comment here which is ignored food: - vegetables: tomatoes - fruits: citrus: oranges tropical: bananas Two items that every GitHub Action YAML must contain is on: and jobs:. on: tells GitHub when something should be run. For example “whenever a pull request is opened”. jobs: tells GitHub what should be run. For example “run this bash script”. runs-on: tells GitHub with what environment should this be run. For example “windows-latest”. 4.1.1 on: When a thing should be run If you are to automate something, step one is to figure out when do you want the thing to happen. What should trigger your action? For that we use on: in a GitHub Action. There’s lots of possible answers for when something should be run. The triggers can be a lot of different events on GitHub: pull requests, issues, comments, times of day, etc. 4.1.2 jobs: What should be run Perhaps even more important, what is the job that this automated task needs to do? Description Trigger term When you click a button workflow_dispatch: When its a certain time of day schedule: When a pull request is opened or has a new commit pull_request: When a branch is merged push: When something happens with an issue issue: When a different github action runs workflow_call: When someone comments on a pull request pull_request_review_comment: Scenario: You are running an analysis using public data that continually has more samples added - You would like the analysis to rerun when new samples are added - You would like to be informed of when the analysis got rerun and what the results were on Slack That’s totally a thing a GitHub action can do! We will walk through some examples like it! And here’s the good news, you don’t have to write things from scratch or know ALL the languages. GitHub marketplace allows you to use really cool actions that other people have created. More on this later. 4.1.3 runs-on: with what: The runs-on: tag specifies with what environment the job is going to be run. What does this mean? Well let’s start by discussing that the term “cloud” computing is a tad misleading. When we send a job to an online service like GitHub Actions, its not a mysterious vague mass. Instead, its being sent to a real computer somewhere and that computer is setting up a computing environment to run your job and sends back the results to you through the GitHub website. What do we mean by a computing environment? As just like when you work on your personal computer, you install, update, and sometimes delete software in order to run different things, the GitHub Actions computers need to do the same in order to run your code. Although some person from Microsoft isn’t setting up a new physical computer and manually installing software, the specs you give underneath runs-on: tell GitHub Actions what kind of set up to use. So for example, there are built in operating systems like windows-latest, mac-latest, and ubuntu-latest. You can see more about the default GitHub runners here. But just like a Windows machine straight out of a box is unlikely to have everything you need to run some code, you may need a more specific computing environment. You can also create custom environments using containerization. 4.1.4 Containerization A “virtual machine” is basically when your computer creates its own fake computer inside of it. It’s acting like a different computer but it doesn’t have any additional physical parts. Containers aren’t virtual machines, but they do a similar thing, which is they spin up a computing environment where you can do things. They are called containers because they are isolated from the rest of your computer. Containerization is useful because it allows us to share our computing environments with others. This is useful because it can be a powerful tool for reproducing analyses if we are controlling our computing environments. The software you use, and the versions of the software you use can affect the results from an analysis (Beaulieu-Jones and Greene 2017). Real data and experiments have shown this! Below is a figure from Beaulieu-Jones and Casey S. Greene, 2017 that shows how a microarray data analysis had different results depending on the software versions used (Beaulieu-Jones and Greene 2017). And as time goes on, your computing environment changes; potentially in ways you don’t realize! Most languages and programs allow you to print out the specifications of your computing environment. See below a “session info” print out from R. What this shows is two different computing environments. Side by side we can see how they differ. There’s various containerization software programs, that will allow you to share your computing environments but a very popular one is Docker. We can picture how this makes analyses more reproducible. Docker and other containerization software work by allowing you to take a snapshot of your environment, called an image. This image can be shared and others can use this image to build the container from which they can run the analysis or whatever it is they plan to do. Docker is a whole other world. There’s whole conferences, hackathons, and etc devoted to Docker and other containerization software. It can be a lot to learn. To start, we recommend borrowing other people’s Docker images as much as possible instead of trying to build your own And then install the few packages you need. (more on this in a future chapter) Super important side note: DO NOT put data that needs to be secured like Personally Identifiable Information (PII) and Personal Health Information (PHI) data on your Docker images! Especially when you share them! They are not meant for this purpose and this data would be exposed! 4.1.4.1 More resources about Docker Launching a Docker image Modifying a Docker image Docker for data scientists 4.1.5 Summarizing GitHub actions are specified by YAML files in .github/workflows/ folder on a GitHub repository. The specs from this YAML are used to run a job when an on trigger specifies it should be run. The runs-on spec tells the server what kind of environment it should be run with. Containers like those made with Docker can help you make custom computing environments. 4.2 Exercise 1 - Running your first GitHub Action Let’s apply what we’ve learned about GitHub Actions by running one! If you don’t have a standard workflow for how you use GitHub locally, or are unhappy with your current methods for this activity we recommend installing GitHub Desktop First we need to create a copy of the exercise GitHub repository we will use for this course. Go to https://github.com/fhdsl/github-action-workshop and click on the Use this template button. Fill out the form on this page about where you want this repository to be and what description you want it to have. And click Create Repository. Clone this repository to your local computer. In GitHub Desktop you can do this by clicking the Clone Repository button. But from command line you can use this kind of command: git clone https://github.com/&lt;your-username&gt;/github-actions-workshop Create a new branch by clicking the buttons as shown here or using the command line examples below cd github-actions-workshop git checkout -b &quot;first-gha&quot; Create the specific GitHub Actions folders. Recall that in order to run a GitHub action, GitHub will look for YAML files in a specific location. We will need to create these folders to get going. Use your operating system to create a .github folder and then inside that folder, a workflows folder. Don’t forget the s in workflows or the . in .github – these folder names have to be exactly written this way for your GitHub Action to be found and recognized by GitHub. You can use this command to do this: mkdir -p .github/workflows Now you will want to move the 00-my-first-action.yml file into the .github/workflows folder. In command line you can do this by using this command: mv activity-1-sample-github-actions/00-my-first-action.yml .github/workflows/00-my-first-action.yml Add and commit these changes to your branch. Then you will want to push your branch to the online GitHub repository. In command line this can be done like this: git add .github/* git commit -m &quot;adding first gha&quot; git push --set-upstream origin first-gha Open a pull request. In GitHub Desktop you can click this button: Or just navigate to your GitHub repository online and open a pull request through the website. Check your pull request to make sure the changes are what you expect. Then merge it! After merging, go to the Actions tab on GitHub You’ll be come very acquainted with this page if you use GitHub actions. On the left shows the workflows that are available or have been run before. We should see our new GitHub Action we just merged from our pull request here called “Basic GitHub Action”. Click on that. Underneath this we should now see a blue banner that allows us to click “Run workflow”. Click Run workflow and then Run workflow again. Because we made our on: trigger workflow_dispatch this means we have to tell the GitHub Action when to run (which means its not really automated in this case). Yay! 4.2.1 Checking results of a GitHub Action Go to the Action tab. You’ll see your newest run of your GitHub Action is logged here. All future GitHub Action runs will have their logs here. Click on the workflow run log so we can look into it. To see more run details we’ll click on the job name which in this case is hello. Click on the dropdown arrows to see even more details on each step. 4.2.2 Breaking down the YAML We can break down how what we wrote in the YAML lead to what is shown in this run’s log. We named this Action Basic GitHub Action and the log was named that. The only job being ran was named hello so in the log it shows up this way underneath the Jobs header. If we had more than one job, those jobs’ names would show up here too. Each job can contain as many steps as we want. Our one step is named Hello World. This step involved running some code using the run: tag which by default uses bash. The bash code just echoed “hello world”. Congrats! You’ve ran your first GitHub Action! In the next chapter we’ll run something a little more automated and a little more fun to build on what we’ve learned here. References "],["automating-re-running-analyses.html", "Chapter 5 Automating Re-running Analyses 5.1 Exercise 2 - Re-run analysis example 5.2 Diving into the details", " Chapter 5 Automating Re-running Analyses In the beginning of this course we discussed the benefits of using continuous integration/continuous deployment principles for scientific code including analyses. In this chapter we will go through example code that shows how this can be set up. We highly encourage you to take this code and adapt it to your own project’s needs. 5.1 Exercise 2 - Re-run analysis example For this exercise, we are going to continue to use the example repository that we set up in the previous chapter. Create a new branch to work from. As is good practice for adapting a GitHub workflow, we will create a new branch for us to work from. In GitHub Desktop you can click the branch button and follow the same steps we did in the previous exercise. From command line: `git checkout -b &quot;more-ghas&quot;` For this exercise we are going to copy over a second GitHub Action YAML file from the folder. This time, move the 01-re-run-analysis.yml file to your .github/workflows directories you made in the previous chapter. From command line: mv activity-1-sample-github-actions/01-re-run-analysis.yml .github/workflows/01-re-run-analysis.yml Now follow the same set of steps we used in the previous chapter to Add, Commit, Push the changes. From command line: git add .github/* git commit -m &quot;adding more ghas&quot; git push --set-upstream origin more-ghas Now create a pull request with the changes you just made. (Refer to the previous chapter if you need reminders on how to do this). After you open your pull request, scroll down to the bottom of the page. If all went as expected, you should see a status message that shows a GitHub Action is running after opening your pull request. Think about it. Without looking at the YAML file… What do you suppose the on: value (the when) might be for these actions? Take a look at the file, .github/workflows/01-re-run-analysis.yml, to see if you are right! On your pull request page on GitHub, click on the Details button next to your workflow run. You can navigate to this same page by going to the Actions tab, then Scrolling down to see the most recent workflow run which should be named Re-run analysis and clicking on that. 5.2 Diving into the details Let’s break down what is in this GitHub Action YAML file and what this workflow run did. 5.2.1 name and on At the top of the file we have: name: Re-run analysis. This is what our workflow run shows up in the Actions tab log as and helps us differentiate it from other GitHub Action Workflows. Below that, there is the on: trigger. This workflow of re-running this analysis will only run when a pull request is open or pushed to. And further we’ve specified with branches: it will only run if the pull request is targeted to branches named main or staging. # Run this workflow when a pull request is opened or pushed to. on: pull_request: branches: [ main, staging ] 5.2.2 jobs In our jobs: we’ve named this job R run analysis. Additionally we are running this on a ubuntu-latest operating system, but as opposed to our first GitHub Action workflow from the previous chapter, where we didn’t need any additional packages or software to run our job, this job, the analysis script we are running, requires things like R, python, and some specific packages. We could, attempt to write a script that installs everything we need. However, that would likely be a lot of work, may not work reliably, and would be hard to track changes. Instead, we are using a custom made docker image that has R, python, and other packages we need already installed. This custom made docker image is pulled from Dockerhub and it exists here. If you wish to make a custom Docker image to use in your analysis, easiest way to do this is to make a Dockerfile, build a Docker image from this file and then push it to Dockerhub. We have some Dockerfiles for this image and others managed and version controlled here on this GitHub repository. You may note we use GitHub Actions on this repository to help us manage these Docker images. jobs: re-run: name: Re run analysis runs-on: ubuntu-latest # This image has python, R and other things we need to run our mock analysis container: image: jhudsl/ottr_python:main 5.2.2.1 actions/checkout One of the most frequently use GitHub Actions from the GitHub Action Marketplace is actions/checkout. This action will grab all the files from a GitHub repository so you can do things with those files in your workflow. (Recall that when you spin up a GitHub Action Environment it is a blank slate, so we have to put our files there too if we want to use them). steps: # Need to get the files specific to our branch from our pull request - name: Checkout files uses: actions/checkout@v3 with: fetch-depth: 0 By default, it will checkout the files from the repository where this action is being run, but we could specify other repository and other branches. fetch-depth: 0 means we will grab all the file. 5.2.2.2 sh run_analysis.sh Now the main objective we were building to. We are going to run a script that re-runs our entire analysis. We’ve named this file run_analysis.sh to be clear about what it does. We’re giving this step an id of running (this will become clear in the next paragraph). Additionally the | tells run: to expect multiple lines of a command. We didn’t need this to be a multiple line command, but we thought it would be good to show you this. # We can call our main script then to re-run it to make sure it works - name: Run it id: running run: | sh run_analysis.sh We have three steps in this fake analysis and the files are numbered in which order they are run. If you open up the run_analysis.sh file, you will see its basically simple workflow step calling file. It looks like this: # This is a mock script that shows how you could have your whole analysis ran by one script call. ## Usage: To re-run this whole analysis, go to bash and # These specs will make sure that if one script fails this will fail the script set -e ## Run the first step python3 &quot;01-python_test.py&quot; ## Run the second step Rscript &quot;02-r_test.R&quot; ## Run a third step Rscript -e &quot;rmarkdown::render(&#39;03-make-a-plot.Rmd&#39;)&quot; The set -e is actually critical here. We need to make sure that this script will stop if it encounters an error. That is the main point of our GitHub Action here, is we want to know if something failed. (We also want to know if the results remained the same, but that will require a bit more engineering than we are showing in this simple example). A very tricky thing about GitHub Actions (and languages called by them) is that GitHub workflows do not always stop when there are errors as we would define them. When designing a new action, we need to carefully evaluate the steps of the job in the logs to make sure what we think happened and completed actually did complete successfully. Returning to our GitHub Action YAML file, we can see that the last step of this job has an if statement. What we are doing here is asking GitHub to evaluate whether the step running (remember the id we set?) had success as its outcome. # We can have this double check that the last step was successfully run - name: Check on re-run outcome if: steps.running.outcome != &#39;success&#39; run: | echo Re-running status ${{steps.running.outcome}} exit 1 This steps.running.outcome is representative of a whole new world of GitHub Actions Environmental variables that we have not discussed yet but we will now! 5.2.3 Summary "],["github-action-variables.html", "Chapter 6 GitHub Action Variables 6.1 Exercise 3 - Exploring Variables", " Chapter 6 GitHub Action Variables The GitHub Actions environments have variables that are already set by default in the environment but you can also set environment variables yourself. 6.0.1 Types of variables There are two types of variables in GitHub Actions. Default - Ones GitHub already sets for you. User set - Ones you set yourself. To print things out, you can use this kind of notation in bash or other contexts in the yaml file. echo ${{ github.repository }} In this next exercise we’ll explore different ways to use variables. 6.1 Exercise 3 - Exploring Variables For this exercise, we are going to continue to use the example repository that we set up in the previous chapter. Create a new branch to work from. From command line: `git checkout -b &quot;env-var&quot;` For this exercise we are going to copy over another GHA yaml to explore. This time, move the exploring-var-and-secrets.yml file to your .github/workflows directories you made in the previous chapter. From command line: mv activity-1-sample-github-actions/exploring-var-and-secrets.yml .github/workflows/exploring-var-and-secrets.yml Now follow the same set of steps we used in the previous chapter to Add, Commit, Push the changes. From command line: git add .github/* git commit -m &quot;exploring gha variables&quot; git push --set-upstream origin env-var Now create a pull request with the changes you just made. (Refer to the previous chapter if you need reminders on how to do this). On your pull request page on GitHub, click on the Details button next to your workflow run. Keep this handy because we will dive into the details of what we just ran. 6.1.1 Default variables You can read the latest documentation about GitHub Action default variables here. But here’s some highlights. name example output explanation GITHUB_REPOSITORY username/repository_name This prints out what repo this is run from GITHUB_REF refs/pull/1/merge The branch or tag that triggered this workflow. But note that this will be blank if the trigger is not based or related to branches or tags. For example a workflow_dispatch wouldn’t have this GITHUB_ACTOR cansavvy The GitHub handle of the person who caused this workflow to run Below shows an example of the log of the where we printed out these default GitHub variables. 6.1.2 User set variables 6.1.2.1 env: There are different ways to set variables. The simplest way to set variables is within a step you can set them using env:. Underneath env: you write the name of the variable on one side of the colon and then the definition on the other side. For example, in our yaml file we had: - name: Hello, but make it personal run: echo &quot;Hello $First_Name.&quot; env: First_Name: Candace This set up printed out Hello Candace in the logs as our output. This might be useful, but if we want an environmental variable to be stored and retrieved between steps we’ll need to use something different. 6.1.2.2 Setting output variables If we’d like one step to be able to retrieve information from another step we’ll need to send a variable to the GITHUB_OUTPUT. To do this we can use this sort of set up: Step that sets a variable depending on some output # How to export a variable to a next step - name: Setting output to the environment at large id: step_name run: echo &quot;results=5&quot; &gt;&gt; $GITHUB_OUTPUT Here we are naming the variable results and the notation &gt;&gt; $GITHUB_OUTPUT is always there. In this example, results is only set equal to 5 but you could see how this might be made to be more complicated. Like perhaps the results are a bash command output like: &quot;time=$(date +&#39;%Y-%m-%d&#39;)&quot; &gt;&gt; $GITHUB_OUTPUT This would allow us to have a time stamp of when this step was run. Or perhaps we are running a script that outputs a result: results=$(Rscript utils/script.R) 6.1.2.3 Using output variables To use this output variable in a subsequent step we have to use this kind of setup: steps.step_name.outputs.results where step_name is the id: we set for the step that set this variable (see above) and results is the name of the variable we set. And, as is typical we need the ${{ }} notation. # How to print out the variable we just saved - name: Print out that variable in a later step run: echo ${{ steps.step_name.outputs.results &gt; 3 }} This is nifty because now we can use the result of one step to determine whether or not we run a subsequent step. GitHub Action steps can have conditional or if statements. Maybe we only want a step to run if the result is something specific: - name: Conditional step # Here we are only going to do this step if the results from the previous step are bigger than 3 if: ${{ steps.step_name.outputs.results &gt; 3 }} run: echo &#39;the results are greater than 3!&#39; Or, maybe we want to make sure the whole workflow shuts down if a variable is something in particular like this example below. - name: Shut it down # Here we are only going to do this step if the results from the previous step are bigger than 3 if: ${{ steps.step_name.outputs.results =&lt; 3 }} run: | echo &#39;the results are less than or equal to 3! -- going to exit!&#39; exit 1 6.1.2.4 Setting and grabbing secrets What if the string or variable we need is not something we can supply in the YAML itself? Perhaps we have credentials or something that cannot be shared publicly but that we need it to complete our steps. That’s where GitHub secrets come in handy! Read more about GitHub secrets here.. One very common type of GitHub secret you may need to add is a GitHub Personal Access Token (sometimes abbreviated PAT). A personal access token is a string set that, when provided, gives access to a user’s GitHub account. Read more about tokens here. For GitHub actions that are doing things that require authorization or particular permissions levels, you will need to provide your GitHub action with your personal access token (PAT) that you store as a GitHub secret. 6.1.3 Activity: Setting GitHub secrets Let’s practice this by setting a GitHub Access token as a secret! 6.1.3.1 Make a Personal Access token You can store any alphanumeric string as your GitHub secret. It may be an API key or authorization keys from some other software program. But for this example, we will use an authorization key for GitHub. Recall we have may have to give authorization to a GitHub action some times, because we are not actually running this with our user account, this job is being sent to GitHub for them to run on their servers somewhere. First make your own personal access token by going here: https://github.com/settings/tokens You can find this page by going to your own profile, and then to Settings and Developer settings. The GitHub Documentation for how to make PATs is here: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens But we’ll walk through it together now. Underneath Tokens (classic) click Generate new token and pick Generate new token (classic). You will likely have to enter your password at this point. Underneath Note write something that will remind you about where you are using this PAT. Check the repo workflow. (Depending on what you are trying to do you may have to check other boxes but for a lot of the permissions you’ll need repo will do). Scroll to the bottom of the page and click Generate. Your token will be shown on the next page. You’ll keep this handy because they won’t show it to you again. Be careful not to share this any place publicly because it will give someone authorization to you GitHub account! 6.1.3.2 Creating a GitHub Secret Return to your repository that we were using for these activities. Settings &gt; Secrets and variables &gt; Actions &gt; New Repository Secret. Name your secret something. In this example, let’s call it GH_PAT. You’ll want to name your secret something that relates to what it is. Now copy and paste in the secret section. 6.1.3.2.1 Referencing a GitHub secret in a GitHub action To retrieve a GitHub secret amidst a GitHub Action workflow run, you do this sort of notation: ${{ secrets.SECRET_NAME}} Where SECRET_NAME directly is the name you used for your GitHub secret. # Here&#39;s how we&#39;d reference a secret - name: How do we reference a GITHUB secret? run: ${ secrets.SECRET_NAME } In the previous step we named our secret GH_PAT so if we needed to use it in our workflow we would use ${ secrets.GH_PAT }. Perhaps at this point you are worried that your logs may accidentally display your GitHub secret if you did something like: run: echo ${ secrets.GH_PAT } But, you don’t have to worry about that part, in your logs your secrets will show as *** and will not be displayed. 6.1.3.2.2 Activity: Using a GitHub secret On your repository, go to your 01-exploring-var-and-secrets.yml file from your working branch. Click the edit this file button. Scroll to the bottom. Uncomment the last step step. It should look like this: # Here&#39;s how we&#39;d reference a secret - name: How do we reference a GITHUB secret? run: ${ secrets.SECRET_NAME } Replace SECRET_NAME with what you named your secret (probably GH_PAT). Commit that change to your file. Push that change to your file. Take a look at the log by clicking Details. What you should see is that the workflow runs again, tries to print the GitHub secret out but really just shows a ***. "],["more-github-actions-examples.html", "Chapter 7 More GitHub Actions Examples", " Chapter 7 More GitHub Actions Examples "],["troubleshooting-github-actions.html", "Chapter 8 Troubleshooting GitHub Actions", " Chapter 8 Troubleshooting GitHub Actions "],["publishing-github-actions-to-the-marketplace.html", "Chapter 9 Publishing GitHub Actions to the Marketplace", " Chapter 9 Publishing GitHub Actions to the Marketplace "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright, Ava Hoffman Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Ava Hoffman, Candace Savonen Package Developers (ottrpal) Candace Savonen, John Muschelli, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-10-18 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 10 References", " Chapter 10 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
