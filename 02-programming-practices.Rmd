# Scientific software development best practices

## Learning Objectives

In this chapter, we will introduce scientific computational analyses as a form of software development, and ...

```{r, fig.align='center', out.width="100%", echo = FALSE }
ottrpal::include_slide("https://docs.google.com/presentation/d/1x0Cnk2Wcsg8HYkmXnXo_0PxmYCxAwzVrUQzb8DUDvTA/edit#slide=id.g1013f9881e2_0_132")
```

## Science, and software, as iterative processes

Scientific papers are often arranged as a list of methods and/or results, building on itself more or less sequentially.
Each figure follows from the previous figure or text description, to describe the data that support a hypothesis or illustrate a conclusion in a linear, "story"-like order.

```{r, fig.align='center', out.width="100%", echo = FALSE }
ottrpal::include_slide("https://docs.google.com/presentation/d/1x0Cnk2Wcsg8HYkmXnXo_0PxmYCxAwzVrUQzb8DUDvTA/edit#slide=id.g24731cad425_0_0")
```

However, the modern process of _doing_ science, itself, is rarely linear.
It is not realistic to do an experiment, and write a manuscript, and publish the paper, in that order and with no other complications -- usually, there is some amount of iteration involved on one or more of these steps:
* You might do an experiment, then summarize it, then run more experiments based on the results to confirm/test/extend your findings
* You might do an experiment, write a manuscript, then revise the manuscript based on feedback from other scientists
* You might submit a manuscript, then a reviewer may request revisions or additional experiments, which will require you to go back and revisit your experimental setup and conclusions

As scientists, we don't generally expect science to be a static, "write once and forget" process.

```{r, fig.align='center', out.width="100%", echo = FALSE }
ottrpal::include_slide("https://docs.google.com/presentation/d/1x0Cnk2Wcsg8HYkmXnXo_0PxmYCxAwzVrUQzb8DUDvTA/edit#slide=id.g287bcb243d2_0_16")
```

The same idea applies to developing research software!
Rarely, you might be able to write a script or program for a scientific study and use it once, for a single well-defined purpose.
But more often, youâ€™ll write a script (or join several of them together in a more complex pipeline) and reuse it, possibly with changes or extensions as the project progresses.

```{r, fig.align='center', out.width="100%", echo = FALSE }
ottrpal::include_slide("https://docs.google.com/presentation/d/1x0Cnk2Wcsg8HYkmXnXo_0PxmYCxAwzVrUQzb8DUDvTA/edit#slide=id.g287bcb243d2_0_46")
```

In this course, through the lens of automation, we hope to familiarize you with some of the skills necessary to think about research software iteratively, from the beginning of a research project.
It is almost always easier to put good software development practices in place proactively, before a project has matured, rather than adding them on once the project is sufficiently complex that they are necessary.

## Software complexity as a spectrum

Not all software is complex, and not all software requires complex infrastructure (or automation, for that matter)!
It can be useful to think about the complexity of software engineering infrastructure necessary for a project as scaling proportionally to the complexity of the software itself:
* Simple software (math, data transformations, procedural/rule-based scripts) requires simpler infrastructure.
* Complex software (e.g. "pipelines" composed of many commands/software packages chained together, "libraries" that are intended to be reused in many different applications) requires more complex infrastructure, to check assumptions and test reproducibility at each step.

```{r, fig.align='center', out.width="100%", echo = FALSE }
ottrpal::include_slide("https://docs.google.com/presentation/d/1x0Cnk2Wcsg8HYkmXnXo_0PxmYCxAwzVrUQzb8DUDvTA/edit#slide=id.g287bcb243d2_0_153")
```

We will take a closer look at two concrete examples, one on each end of the spectrum, in the next section.

## Examples

### t-test

### Sequencing analysis

## Automation for scientific software
